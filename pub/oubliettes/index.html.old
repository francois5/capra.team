<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Oubliettes</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><rect fill='%23000' width='64' height='64'/><circle cx='32' cy='38' r='12' fill='%23daa520'/><circle cx='28' cy='35' r='2' fill='%23000'/><circle cx='36' cy='35' r='2' fill='%23000'/><path d='M 26 40 Q 32 43 38 40' stroke='%23000' stroke-width='1.5' fill='none'/><path d='M 20 28 L 32 8 L 44 28 Z' fill='%234a148c'/><circle cx='32' cy='12' r='3' fill='%23ffeb3b'/><path d='M 30 8 L 32 4 L 34 8' fill='%23ffeb3b'/><circle cx='26' cy='10' r='1.5' fill='%23ffeb3b'/><circle cx='38' cy='10' r='1.5' fill='%23ffeb3b'/><rect x='28' y='48' width='8' height='10' fill='%236a1b9a' rx='1'/><path d='M 20 50 L 18 54 L 22 52 Z' fill='%234a148c'/><path d='M 44 50 L 46 54 L 42 52 Z' fill='%234a148c'/><circle cx='15' cy='30' r='2' fill='%23ffeb3b' opacity='0.7'/><circle cx='49' cy='30' r='2' fill='%23ffeb3b' opacity='0.7'/><circle cx='12' cy='38' r='1.5' fill='%23ffeb3b' opacity='0.5'/><circle cx='52' cy='38' r='1.5' fill='%23ffeb3b' opacity='0.5'/></svg>">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: 'Arial', sans-serif;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            cursor: crosshair;
        }

        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 14px;
        }

        #controls {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 12px;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="loading">üîÑ Chargement d'Oubliettes...</div>

    <div id="info" style="display:none;">
        <div>üßô <strong>Oubliettes</strong></div>
        <div>Blocs min√©s: <span id="minedCount">0</span></div>
        <div>Position: <span id="position">0, 0</span></div>
        <div>Profondeur: <span id="depth">0</span> blocs sous la surface</div>
        <div>√âtat: <span id="playerState">Debout</span></div>
        <div>‚ù§Ô∏è Sant√©: <span id="health">200</span> / 200 <span id="restIndicator"></span></div>
        <div>‚ú® Mana: <span id="mana">100</span> / 100</div>
        <div>üë• Alli√©s: <span id="allies">0</span> / <span id="maxAllies">0</span></div>
        <div id="debugMode" style="display:none; color: #FFD700;">üì∑ Mode Cam√©ra Libre (B pour d√©sactiver)</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="controls" style="display:none;">
        ‚¨ÖÔ∏è Q : Gauche | ‚û°Ô∏è D : Droite | ‚¨ÜÔ∏è Z/W : Sauter | ‚¨áÔ∏è S/Shift : S'accroupir | ‚öîÔ∏è A : Attaquer | üîß E : Utiliser | ‚ú® C : Convertir | ‚ù§Ô∏è H : R√©g√©n√©ration | ‚õèÔ∏è R : Creuser galerie | üñ±Ô∏è Clic : Creuser/Placer
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Configuration
        const BLOCK_SIZE = 32;
        const GRID_WIDTH = 100;
        const GRID_HEIGHT = 256;  // 256 blocs de haut: bedrock en bas, surface infranchissable en haut
        let VIEWPORT_WIDTH = 25;
        let VIEWPORT_HEIGHT = 20;

        // Fonction pour redimensionner le canvas en plein √©cran
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            VIEWPORT_WIDTH = Math.ceil(canvas.width / BLOCK_SIZE);
            VIEWPORT_HEIGHT = Math.ceil(canvas.height / BLOCK_SIZE);
        }

        // Initialiser et √©couter les changements de taille
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const VISION_RADIUS = 15;  // Rayon de vision augment√© pour le monde plus grand

        // Types de blocs
        const BLOCKS = {
            AIR: 0,
            DIRT: 1,
            STONE: 2,
            GRASS: 3,
            BEDROCK: 4,
            TORCH: 5,              // Torche (territoire de la Lumi√®re)
            STAIRS: 6,             // Escalier vers la surface
            STONE_LIGHT: 7,        // Pierre marqu√©e Lumi√®re
            STONE_SHADOW: 8        // Pierre marqu√©e Ombre
        };

        const BLOCK_COLORS = {
            [BLOCKS.AIR]: 'transparent',
            [BLOCKS.DIRT]: '#8B4513',
            [BLOCKS.STONE]: '#808080',
            [BLOCKS.GRASS]: '#7CFC00',
            [BLOCKS.BEDROCK]: '#1a1a1a',
            [BLOCKS.TORCH]: '#FFD700',         // Or/jaune
            [BLOCKS.STAIRS]: '#A0522D',        // Brun fonc√©
            [BLOCKS.STONE_LIGHT]: '#A9A9A9',   // Pierre grise claire
            [BLOCKS.STONE_SHADOW]: '#696969'   // Pierre grise fonc√©e
        };

        // Territoires des grottes
        const TERRITORY_TYPES = {
            NEUTRAL: 0,
            LIGHT: 1,    // Territoire de la Lumi√®re (gardiens, torches, escalier)
            SHADOW: 2    // Territoire de l'Ombre (cr√©atures)
        };

        // Stocker les territoires et entit√©s
        let territories = [];
        let entities = [];
        let caveMarkers = [];  // Marqueurs sur les bords des grottes
        let stairwayLocations = [];  // Position des escaliers (pour affichage de l'art)

        // Grille du monde
        let world = [];
        let minedCount = 0;

        // Cam√©ra
        const camera = {
            x: 0,
            y: 0,
            freeView: false,  // Mode debug de cam√©ra libre
            freeX: 0,
            freeY: 0,
            freeSpeed: 1  // Vitesse de d√©placement en mode libre
        };

        // Sprites
        const sprites = {
            heroIdle: null,
            heroWalkLeft: null,
            heroWalkRight: null,
            heroCrawlLeft: null,
            heroCrawlRight: null,
            heroCrouchIdle: null,
            heroJump: null,
            stairway: null,
            blackRam: null,
            ratmanIdle: null,
            ratmanWalkLeft: null,
            ratmanWalkRight: null,
            ratmanAttackLeft: null,
            ratmanAttackRight: null,
            loaded: false
        };

        // Charger les sprites
        function loadSprites() {
            return new Promise((resolve) => {
                let loadedCount = 0;
                const totalSprites = 14;  // 7 h√©ros + 1 escalier + 1 b√©lier + 5 homme-rat

                function checkComplete() {
                    loadedCount++;
                    if (loadedCount === totalSprites) {
                        sprites.loaded = true;
                        resolve();
                    }
                }

                sprites.heroIdle = new Image();
                sprites.heroIdle.onload = checkComplete;
                sprites.heroIdle.onerror = () => { console.warn('Idle sprite non charg√©'); checkComplete(); };
                sprites.heroIdle.src = 'assets/sprites/hero/idle-256px-16.png';

                sprites.heroWalkLeft = new Image();
                sprites.heroWalkLeft.onload = checkComplete;
                sprites.heroWalkLeft.onerror = () => { console.warn('Walk-left sprite non charg√©'); checkComplete(); };
                sprites.heroWalkLeft.src = 'assets/sprites/hero/walk-left-256px-16.png';

                sprites.heroWalkRight = new Image();
                sprites.heroWalkRight.onload = checkComplete;
                sprites.heroWalkRight.onerror = () => { console.warn('Walk-right sprite non charg√©'); checkComplete(); };
                sprites.heroWalkRight.src = 'assets/sprites/hero/walk-right-256px-16.png';

                sprites.heroCrawlLeft = new Image();
                sprites.heroCrawlLeft.onload = checkComplete;
                sprites.heroCrawlLeft.onerror = () => { console.warn('Crawl-left sprite non charg√©'); checkComplete(); };
                sprites.heroCrawlLeft.src = 'assets/sprites/hero/crawl-left-256px-16.png';

                sprites.heroCrawlRight = new Image();
                sprites.heroCrawlRight.onload = checkComplete;
                sprites.heroCrawlRight.onerror = () => { console.warn('Crawl-right sprite non charg√©'); checkComplete(); };
                sprites.heroCrawlRight.src = 'assets/sprites/hero/crawl-right-256px-16.png';

                sprites.heroCrouchIdle = new Image();
                sprites.heroCrouchIdle.onload = checkComplete;
                sprites.heroCrouchIdle.onerror = () => { console.warn('Crouch-idle sprite non charg√©'); checkComplete(); };
                sprites.heroCrouchIdle.src = 'assets/sprites/hero/crouch-idle-256px-16.png';

                sprites.heroJump = new Image();
                sprites.heroJump.onload = checkComplete;
                sprites.heroJump.onerror = () => { console.warn('Jump sprite non charg√©'); checkComplete(); };
                sprites.heroJump.src = 'assets/sprites/hero/jump-256px-16.png';

                sprites.stairway = new Image();
                sprites.stairway.onload = checkComplete;
                sprites.stairway.onerror = () => { console.warn('Stairway art non charg√©'); checkComplete(); };
                sprites.stairway.src = 'assets/art/stairway.webp';

                sprites.blackRam = new Image();
                sprites.blackRam.onload = checkComplete;
                sprites.blackRam.onerror = () => { console.warn('Black ram sprite non charg√©'); checkComplete(); };
                sprites.blackRam.src = 'assets/sprites/black-ram/black-sheep-256px-16.png';

                sprites.ratmanIdle = new Image();
                sprites.ratmanIdle.onload = checkComplete;
                sprites.ratmanIdle.onerror = () => { console.warn('Ratman idle sprite non charg√©'); checkComplete(); };
                sprites.ratmanIdle.src = 'assets/sprites/giant-rat/idle-256px-16.png';

                sprites.ratmanWalkLeft = new Image();
                sprites.ratmanWalkLeft.onload = checkComplete;
                sprites.ratmanWalkLeft.onerror = () => { console.warn('Ratman walk-left sprite non charg√©'); checkComplete(); };
                sprites.ratmanWalkLeft.src = 'assets/sprites/giant-rat/walk-left-giant-rat-256px-16.png';

                sprites.ratmanWalkRight = new Image();
                sprites.ratmanWalkRight.onload = checkComplete;
                sprites.ratmanWalkRight.onerror = () => { console.warn('Ratman walk-right sprite non charg√©'); checkComplete(); };
                sprites.ratmanWalkRight.src = 'assets/sprites/giant-rat/walk-right-giant-rat-256px-16.png';

                sprites.ratmanAttackLeft = new Image();
                sprites.ratmanAttackLeft.onload = checkComplete;
                sprites.ratmanAttackLeft.onerror = () => { console.warn('Ratman attack-left sprite non charg√©'); checkComplete(); };
                sprites.ratmanAttackLeft.src = 'assets/sprites/giant-rat/attaque-left-256px-16.png';

                sprites.ratmanAttackRight = new Image();
                sprites.ratmanAttackRight.onload = checkComplete;
                sprites.ratmanAttackRight.onerror = () => { console.warn('Ratman attack-right sprite non charg√©'); checkComplete(); };
                sprites.ratmanAttackRight.src = 'assets/sprites/giant-rat/attaque-right-256px-16.png';
            });
        }

        // G√©n√©rateur de bruit de Perlin
        class PerlinNoise {
            constructor() {
                this.permutation = [];
                for (let i = 0; i < 256; i++) {
                    this.permutation[i] = i;
                }
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.permutation[i], this.permutation[j]] = [this.permutation[j], this.permutation[i]];
                }
                this.permutation = this.permutation.concat(this.permutation);
            }

            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }

            lerp(t, a, b) {
                return a + t * (b - a);
            }

            grad(hash, x, y) {
                const h = hash & 3;
                const u = h < 2 ? x : y;
                const v = h < 2 ? y : x;
                return ((h & 1) ? -u : u) + ((h & 2) ? -2.0 * v : 2.0 * v);
            }

            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = this.fade(x);
                const v = this.fade(y);
                const a = this.permutation[X] + Y;
                const b = this.permutation[X + 1] + Y;
                return this.lerp(v,
                    this.lerp(u, this.grad(this.permutation[a], x, y),
                        this.grad(this.permutation[b], x - 1, y)),
                    this.lerp(u, this.grad(this.permutation[a + 1], x, y - 1),
                        this.grad(this.permutation[b + 1], x - 1, y - 1))
                );
            }

            octaveNoise(x, y, octaves, persistence) {
                let total = 0;
                let frequency = 1;
                let amplitude = 1;
                let maxValue = 0;

                for (let i = 0; i < octaves; i++) {
                    total += this.noise(x * frequency, y * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= 2;
                }

                return total / maxValue;
            }
        }

        const perlin = new PerlinNoise();

        // Joueur
        const player = {
            x: GRID_WIDTH / 2,
            y: GRID_HEIGHT * 0.8,  // D√©part proche de la surface (80% de la hauteur)
            width: 0.6,
            height: 1.8,
            normalHeight: 1.8,
            crouchHeight: 0.9,
            vx: 0,
            vy: 0,
            speed: 0.15,
            crouchSpeed: 0.08,
            jumpPower: 0.5,
            onGround: false,
            isCrouching: false,
            facing: 'right',  // Direction du regard
            isMoving: false,
            animFrame: 0,
            animSpeed: 0.05,  // R√©duit de 0.08 √† 0.05 pour ralentir les animations

            // Syst√®me de combat
            isAttacking: false,
            attackCooldown: 0,
            attackRange: 1.5,  // Port√©e d'attaque
            attackDamage: 10,  // D√©g√¢ts par attaque

            // Syst√®me de magie
            mana: 100,
            maxMana: 100,
            manaRegen: 0.1,  // R√©g√©n√©ration par frame

            // Syst√®me d'alli√©s
            maxAllies: 0,  // Nombre maximum de monstres alli√©s (augmente avec chaque b√©lier converti)
            currentAllies: 0,  // Nombre actuel de monstres alli√©s

            // Syst√®me de sant√©
            health: 200,
            maxHealth: 200,
            healthRegen: 4 / 60,  // R√©g√©n√©ration: 4 HP par seconde = 4/60 par frame
            restTimer: 0  // Compteur pour le repos (2 secondes = 120 frames)
        };

        const GRAVITY = 0.03;
        const MAX_FALL_SPEED = 0.8;

        // D√©tecter les grottes (zones d'air connect√©es)
        function detectCaves() {
            const caves = [];
            const visited = Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(false));

            function floodFill(startX, startY) {
                const cave = [];
                const stack = [[startX, startY]];

                while (stack.length > 0) {
                    const [x, y] = stack.pop();

                    if (x < 0 || x >= GRID_WIDTH || y < 0 || y >= GRID_HEIGHT) continue;
                    if (visited[y][x] || world[y][x] !== BLOCKS.AIR) continue;

                    visited[y][x] = true;
                    cave.push([x, y]);

                    // V√©rifier les 4 directions
                    stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
                }

                return cave;
            }

            // Parcourir la grille pour trouver toutes les grottes
            for (let y = 1; y < GRID_HEIGHT - 20; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (world[y][x] === BLOCKS.AIR && !visited[y][x]) {
                        const cave = floodFill(x, y);
                        // Grottes moyennes: entre 40 et 300 blocs
                        if (cave.length >= 40 && cave.length <= 300) {
                            caves.push(cave);
                        }
                    }
                }
            }

            console.log(`üèîÔ∏è ${caves.length} grottes d√©tect√©es`);
            return caves;
        }

        // Trouver les bords d'une grotte (blocs solides adjacents √† l'air de la grotte)
        function findCaveBorders(cave) {
            const borders = [];
            const caveSet = new Set(cave.map(([x, y]) => `${x},${y}`));

            for (const [x, y] of cave) {
                // V√©rifier les 8 directions (incluant diagonales)
                const neighbors = [
                    [x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1],
                    [x - 1, y - 1], [x + 1, y - 1], [x - 1, y + 1], [x + 1, y + 1]
                ];

                for (const [nx, ny] of neighbors) {
                    if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                        // Si le voisin n'est pas dans la grotte et est un bloc solide
                        if (!caveSet.has(`${nx},${ny}`) && world[ny][nx] !== BLOCKS.AIR) {
                            const borderKey = `${nx},${ny}`;
                            if (!borders.some(([bx, by]) => `${bx},${by}` === borderKey)) {
                                borders.push([nx, ny]);
                            }
                        }
                    }
                }
            }

            return borders;
        }

        // Assigner des territoires aux grottes
        function assignTerritories(caves) {
            territories = [];
            entities = [];
            caveMarkers = [];
            stairwayLocations = [];

            for (const cave of caves) {
                // Probabilit√©: 10% Lumi√®re, 40% Ombre, 50% Neutre
                const rand = Math.random();
                let territoryType = TERRITORY_TYPES.NEUTRAL;

                if (rand < 0.10) {
                    territoryType = TERRITORY_TYPES.LIGHT;
                } else if (rand < 0.50) {
                    territoryType = TERRITORY_TYPES.SHADOW;
                }

                if (territoryType !== TERRITORY_TYPES.NEUTRAL) {
                    // Calculer le centre de la grotte
                    const centerX = Math.floor(cave.reduce((sum, [x]) => sum + x, 0) / cave.length);
                    const centerY = Math.floor(cave.reduce((sum, [, y]) => sum + y, 0) / cave.length);

                    territories.push({
                        type: territoryType,
                        cave: cave,
                        centerX: centerX,
                        centerY: centerY
                    });

                    // Trouver et marquer les bords de la grotte
                    const borders = findCaveBorders(cave);
                    const marker = territoryType === TERRITORY_TYPES.LIGHT ? 'üåü' : 'üåë';
                    const stoneType = territoryType === TERRITORY_TYPES.LIGHT ? BLOCKS.STONE_LIGHT : BLOCKS.STONE_SHADOW;

                    for (const [bx, by] of borders) {
                        // Remplacer la pierre par de la pierre marqu√©e
                        if (world[by][bx] === BLOCKS.STONE || world[by][bx] === BLOCKS.DIRT) {
                            world[by][bx] = stoneType;
                        }

                        caveMarkers.push({
                            x: bx,
                            y: by,
                            symbol: marker,
                            type: territoryType
                        });
                    }

                    if (territoryType === TERRITORY_TYPES.LIGHT) {
                        // Cr√©er un escalier vers la surface
                        createStaircase(centerX, centerY);

                        // Placer des torches
                        placeTorches(cave, 5);

                        console.log(`üí° Territoire de la Lumi√®re cr√©√© en (${centerX}, ${centerY}) avec ${borders.length} marqueurs`);
                    } else if (territoryType === TERRITORY_TYPES.SHADOW) {
                        // Cr√©er un b√©lier noir au centre de la grotte
                        entities.push({
                            type: 'black_ram',
                            x: centerX,
                            y: centerY,
                            color: '#4B0082',
                            animFrame: 0,
                            animSpeed: 0.05,
                            alignment: 'shadow',      // Alignement Ombre
                            summonTimer: 0,           // Timer pour invoquer des monstres
                            summonInterval: 300,      // Invoquer toutes les 5 secondes (300 frames √† 60fps)
                            maxSummons: 1,            // Maximum 1 monstre invoqu√© √† la fois
                            currentSummons: 0,        // Nombre actuel de monstres invoqu√©s
                            loyalty: 100,             // Loyaut√© du b√©lier (0-100)
                            maxLoyalty: 100,
                            health: 100,              // Points de vie du b√©lier
                            maxHealth: 100,
                            invokeCooldown: 0         // Cooldown pour invoquer devant le b√©lier
                        });

                        console.log(`üåë Territoire de l'Ombre cr√©√© en (${centerX}, ${centerY}) avec ${borders.length} marqueurs et 1 b√©lier`);
                    }
                }
            }

            console.log(`üìç ${caveMarkers.length} marqueurs de territoire plac√©s`);
        }

        // Cr√©er un escalier vers la surface
        function createStaircase(startX, startY) {
            let x = startX;
            let y = startY;

            // Cr√©er un sol horizontal de 3 blocs pour poser l'escalier
            const floorY = y;
            for (let fx = startX - 1; fx <= startX + 1; fx++) {
                if (fx >= 0 && fx < GRID_WIDTH && floorY > 0) {
                    world[floorY][fx] = BLOCKS.STONE;  // Sol en pierre
                    // D√©gager l'espace au-dessus
                    if (floorY + 1 < GRID_HEIGHT) world[floorY + 1][fx] = BLOCKS.AIR;
                    if (floorY + 2 < GRID_HEIGHT) world[floorY + 2][fx] = BLOCKS.AIR;
                    if (floorY + 3 < GRID_HEIGHT) world[floorY + 3][fx] = BLOCKS.AIR;
                }
            }

            // Enregistrer la position du sol pour l'art de l'escalier (pos√© SUR le sol)
            stairwayLocations.push({
                x: startX,
                y: floorY + 1,  // 1 bloc au-dessus du sol
                loyalty: 100,   // Loyaut√© de l'escalier (0-100)
                maxLoyalty: 100,
                invokeCooldown: 0  // Cooldown pour invoquer
            });

            // Monter jusqu'√† la zone de protection du ch√¢teau
            while (y < GRID_HEIGHT - 25) {
                if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT - 20) {
                    world[y][x] = BLOCKS.STAIRS;
                    // Cr√©er de l'espace autour de l'escalier
                    if (x + 1 < GRID_WIDTH) world[y][x + 1] = BLOCKS.AIR;
                    if (x - 1 >= 0) world[y][x - 1] = BLOCKS.AIR;
                }
                y++;
                // Varier l√©g√®rement la position x pour un effet naturel
                if (Math.random() > 0.7) {
                    x += Math.random() > 0.5 ? 1 : -1;
                }
            }
        }

        // Placer des torches dans une grotte
        function placeTorches(cave, count) {
            const positions = [...cave];
            for (let i = 0; i < count && positions.length > 0; i++) {
                const idx = Math.floor(Math.random() * positions.length);
                const [x, y] = positions.splice(idx, 1)[0];

                // Placer une torche si il y a un mur adjacent
                if (y > 0 && world[y - 1][x] !== BLOCKS.AIR) {
                    world[y][x] = BLOCKS.TORCH;
                }
            }
        }

        // Initialiser le monde
        function initWorld() {
            console.log('üåç G√©n√©ration du monde avec Perlin noise...');
            world = [];
            const scale = 0.05;  // √âchelle augment√©e pour des grottes plus petites
            const caveThreshold = 0.35;  // Seuil augment√© pour moins d'air

            for (let y = 0; y < GRID_HEIGHT; y++) {
                world[y] = [];
                for (let x = 0; x < GRID_WIDTH; x++) {
                    // Bedrock en bas (niveau 0)
                    if (y === 0) {
                        world[y][x] = BLOCKS.BEDROCK;
                        continue;
                    }

                    // Surface infranchissable en haut (niveau 255) - Ch√¢teau de la Lumi√®re
                    if (y === GRID_HEIGHT - 1) {
                        world[y][x] = BLOCKS.BEDROCK;
                        continue;
                    }

                    // Zone de protection du ch√¢teau (20 blocs sous la surface)
                    if (y >= GRID_HEIGHT - 20) {
                        world[y][x] = BLOCKS.BEDROCK;
                        continue;
                    }

                    const noiseValue = perlin.octaveNoise(x * scale, y * scale, 4, 0.5);

                    if (noiseValue > caveThreshold) {
                        world[y][x] = BLOCKS.AIR;
                    } else {
                        const depth = y;  // Profondeur depuis le bas
                        if (depth < 30) {
                            world[y][x] = BLOCKS.BEDROCK;
                        } else if (depth < 150) {
                            // Plus de pierre (au lieu de 100)
                            world[y][x] = BLOCKS.STONE;
                        } else {
                            world[y][x] = BLOCKS.DIRT;
                        }
                    }
                }
            }

            // Grotte de d√©part proche de la surface (20% depuis le haut)
            const centerX = Math.floor(GRID_WIDTH / 2);
            const centerY = Math.floor(GRID_HEIGHT * 0.8);  // 80% de la hauteur
            for (let dy = -3; dy <= 3; dy++) {
                for (let dx = -3; dx <= 3; dx++) {
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= 3) {
                        const y = centerY + dy;
                        const x = centerX + dx;
                        if (y > 0 && y < GRID_HEIGHT - 20 && x >= 0 && x < GRID_WIDTH) {
                            world[y][x] = BLOCKS.AIR;
                        }
                    }
                }
            }

            // D√©tecter les grottes et assigner les territoires
            const caves = detectCaves();
            assignTerritories(caves);

            // Ajouter le rat g√©ant co-d√©tenu au d√©part (non converti)
            entities.push({
                type: 'ratman',
                x: centerX + 2,  // √Ä c√¥t√© du joueur
                y: centerY,
                vx: 0,
                vy: 0,
                color: '#8B4513',  // Marron (shadow)
                animFrame: 0,
                animSpeed: 0.05,
                summonedBy: null,
                lifetime: Infinity,  // Ne dispara√Æt jamais
                facing: 'left',
                isMoving: false,
                isAttacking: false,
                attackCooldown: 0,
                health: 100,
                maxHealth: 100,
                loyalty: 100,  // Loyaut√© √† 100 = doit √™tre converti
                maxLoyalty: 100,
                alignment: 'shadow'  // Alignement Ombre (pas encore converti)
            });
            player.currentAllies = 0;  // Commencer avec 0 alli√©
            player.maxAllies = 1;  // Et 1 place d'alli√© disponible
            console.log('üêÄ Rat g√©ant co-d√©tenu ajout√© dans la grotte de d√©part');

            console.log('‚úÖ Monde g√©n√©r√© !');
        }

        // V√©rifier collision
        function checkCollision(x, y, width, height) {
            const points = [
                [x, y],
                [x + width, y],
                [x, y + height],
                [x + width, y + height],
                [x + width/2, y],
                [x + width/2, y + height],
            ];

            for (let [px, py] of points) {
                const bx = Math.floor(px);
                const by = Math.floor(py);

                if (bx >= 0 && bx < GRID_WIDTH && by >= 0 && by < GRID_HEIGHT) {
                    if (world[by][bx] !== BLOCKS.AIR) {
                        return true;
                    }
                }
            }
            return false;
        }

        // Mettre √† jour la physique
        function updatePhysics() {
            // V√©rifier automatiquement l'√©tat du plafond
            const canStandUp = !checkCollision(player.x, player.y, player.width, player.normalHeight);
            const shiftPressed = keys['shift'] || keys['s'];

            // Logique de crouch automatique:
            // - Si le plafond est trop bas: forcer accroupi
            // - Si le plafond est ok ET shift n'est pas appuy√©: se relever
            if (!canStandUp) {
                // Plafond trop bas: forcer l'accroupissement
                player.isCrouching = true;
                player.height = player.crouchHeight;
            } else if (!shiftPressed && player.isCrouching) {
                // Espace suffisant et shift rel√¢ch√©: se relever automatiquement
                player.isCrouching = false;
                player.height = player.normalHeight;
            }

            player.vy -= GRAVITY;
            if (player.vy < -MAX_FALL_SPEED) {
                player.vy = -MAX_FALL_SPEED;
            }

            const newX = player.x + player.vx;
            if (!checkCollision(newX, player.y, player.width, player.height)) {
                player.x = newX;
            }
            player.vx *= 0.8;

            const newY = player.y + player.vy;
            if (!checkCollision(player.x, newY, player.width, player.height)) {
                player.y = newY;
                player.onGround = false;
            } else {
                if (player.vy < 0) {
                    player.y = Math.floor(player.y);
                    player.onGround = true;
                }
                player.vy = 0;
            }

            player.x = Math.max(0, Math.min(GRID_WIDTH - player.width, player.x));
            player.y = Math.max(0, Math.min(GRID_HEIGHT - player.height, player.y));

            // Animation
            player.isMoving = Math.abs(player.vx) > 0.01;
            if (player.isMoving) {
                player.animFrame += player.animSpeed;
                if (player.animFrame >= 16) player.animFrame = 0;
            } else {
                player.animFrame += player.animSpeed * 0.5;
                if (player.animFrame >= 16) player.animFrame = 0;
            }
        }

        // Mettre √† jour la cam√©ra
        function updateCamera() {
            if (camera.freeView) {
                // Mode cam√©ra libre: contr√¥les ZQSD/fl√®ches
                if (keys['z'] || keys['w'] || keys['arrowup']) {
                    camera.freeY += camera.freeSpeed;
                }
                if (keys['s'] || keys['arrowdown']) {
                    camera.freeY -= camera.freeSpeed;
                }
                if (keys['q'] || keys['a'] || keys['arrowleft']) {
                    camera.freeX -= camera.freeSpeed;
                }
                if (keys['d'] || keys['arrowright']) {
                    camera.freeX += camera.freeSpeed;
                }

                camera.x = camera.freeX;
                camera.y = camera.freeY;
            } else {
                // Mode normal: suivre le joueur
                camera.x = player.x - VIEWPORT_WIDTH / 2;
                camera.y = player.y - VIEWPORT_HEIGHT / 2;
            }

            // Limites de la cam√©ra
            camera.x = Math.max(0, Math.min(GRID_WIDTH - VIEWPORT_WIDTH, camera.x));
            camera.y = Math.max(0, Math.min(GRID_HEIGHT - VIEWPORT_HEIGHT, camera.y));
        }

        // Dessiner le monde
        function drawWorld() {
            updateCamera();

            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const startX = Math.floor(camera.x);
            const startY = Math.floor(camera.y);
            const endX = Math.ceil(camera.x + VIEWPORT_WIDTH);
            const endY = Math.ceil(camera.y + VIEWPORT_HEIGHT);

            for (let y = startY; y < endY && y < GRID_HEIGHT; y++) {
                for (let x = startX; x < endX && x < GRID_WIDTH; x++) {
                    if (x < 0 || y < 0) continue;

                    const screenX = (x - camera.x) * BLOCK_SIZE;
                    const screenY = canvas.height - ((y - camera.y + 1) * BLOCK_SIZE);

                    const dx = x - player.x;
                    const dy = y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (world[y][x] !== BLOCKS.AIR) {
                        const blockType = world[y][x];
                        ctx.fillStyle = BLOCK_COLORS[blockType];
                        ctx.fillRect(screenX, screenY, BLOCK_SIZE, BLOCK_SIZE);

                        // Effet sp√©cial pour les torches (lueur)
                        if (blockType === BLOCKS.TORCH) {
                            const gradient = ctx.createRadialGradient(
                                screenX + BLOCK_SIZE / 2, screenY + BLOCK_SIZE / 2, 0,
                                screenX + BLOCK_SIZE / 2, screenY + BLOCK_SIZE / 2, BLOCK_SIZE * 2
                            );
                            gradient.addColorStop(0, 'rgba(255, 215, 0, 0.4)');
                            gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                            ctx.fillStyle = gradient;
                            ctx.fillRect(screenX - BLOCK_SIZE, screenY - BLOCK_SIZE, BLOCK_SIZE * 3, BLOCK_SIZE * 3);
                        }

                        // Afficher les marqueurs de territoire sur les bords des grottes
                        const marker = caveMarkers.find(m => m.x === x && m.y === y);
                        if (marker) {
                            // Fond semi-transparent
                            const bgColor = marker.type === TERRITORY_TYPES.LIGHT
                                ? 'rgba(255, 215, 0, 0.3)'
                                : 'rgba(75, 0, 130, 0.3)';
                            ctx.fillStyle = bgColor;
                            ctx.fillRect(screenX, screenY, BLOCK_SIZE, BLOCK_SIZE);

                            // Emoji
                            ctx.font = '20px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(marker.symbol, screenX + BLOCK_SIZE / 2, screenY + BLOCK_SIZE / 2);
                        }

                        // Bordures 3D (sauf pour torches et escaliers)
                        if (blockType !== BLOCKS.TORCH && blockType !== BLOCKS.STAIRS && blockType !== BLOCKS.AIR) {
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                            ctx.fillRect(screenX, screenY, BLOCK_SIZE, 2);
                            ctx.fillRect(screenX, screenY, 2, BLOCK_SIZE);

                            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                            ctx.fillRect(screenX, screenY + BLOCK_SIZE - 2, BLOCK_SIZE, 2);
                            ctx.fillRect(screenX + BLOCK_SIZE - 2, screenY, 2, BLOCK_SIZE);
                        }
                    }

                    if (distance <= VISION_RADIUS) {
                        const darknessLevel = distance / VISION_RADIUS;
                        const fogAlpha = darknessLevel * 0.85;

                        if (fogAlpha > 0) {
                            ctx.fillStyle = `rgba(0, 0, 0, ${fogAlpha})`;
                            ctx.fillRect(screenX, screenY, BLOCK_SIZE, BLOCK_SIZE);
                        }
                    } else {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
                        ctx.fillRect(screenX, screenY, BLOCK_SIZE, BLOCK_SIZE);
                    }

                    // Effet de lumi√®re du Ch√¢teau (lueur dor√©e en haut)
                    if (y >= GRID_HEIGHT - 30) {
                        const distanceFromTop = GRID_HEIGHT - y;
                        const lightIntensity = (30 - distanceFromTop) / 30;  // 0 √† 1
                        const alpha = lightIntensity * 0.3;
                        ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;  // Or dor√©
                        ctx.fillRect(screenX, screenY, BLOCK_SIZE, BLOCK_SIZE);
                    }
                }
            }

            drawPlayer();
            drawStairways();
            drawEntities();
            drawInvocationLightning();
            drawHealingLightning();
        }

        // Dessiner l'√©clair magique d'invocation
        function drawInvocationLightning() {
            if (!isInvoking || !currentInvokeTarget) return;

            // Calculer les positions de d√©part (joueur) et d'arriv√©e (cible)
            const startX = (player.x - camera.x) * BLOCK_SIZE + (player.width * BLOCK_SIZE) / 2;
            const startY = canvas.height - ((player.y - camera.y + player.normalHeight / 2) * BLOCK_SIZE);

            let endX, endY;
            if (currentInvokeTarget.type === 'ratman' || currentInvokeTarget.type === 'black_ram' || currentInvokeTarget.type === 'golden_ram') {
                endX = (currentInvokeTarget.x - camera.x) * BLOCK_SIZE + BLOCK_SIZE / 2;
                endY = canvas.height - ((currentInvokeTarget.y - camera.y + 1) * BLOCK_SIZE);
            } else {
                // Pour les escaliers
                endX = (currentInvokeTarget.x - camera.x) * BLOCK_SIZE;
                endY = canvas.height - ((currentInvokeTarget.y - camera.y) * BLOCK_SIZE);
            }

            // Dessiner l'√©clair bleu avec effet d'ondulation
            ctx.save();
            ctx.strokeStyle = `rgba(0, 150, 255, ${0.7 + Math.sin(Date.now() / 50) * 0.3})`;
            ctx.lineWidth = 3;
            ctx.shadowColor = '#00AAFF';
            ctx.shadowBlur = 15;

            ctx.beginPath();
            ctx.moveTo(startX, startY);

            // Cr√©er un √©clair avec segments en zigzag
            const segments = 6;
            const zigzagAmount = 20;

            for (let i = 1; i < segments; i++) {
                const t = i / segments;
                const baseX = startX + (endX - startX) * t;
                const baseY = startY + (endY - startY) * t;

                // Ajouter une ondulation perpendiculaire
                const dx = endX - startX;
                const dy = endY - startY;
                const perpX = -dy;
                const perpY = dx;
                const length = Math.sqrt(perpX * perpX + perpY * perpY);
                const offsetAmount = (Math.sin(Date.now() / 30 + i) * zigzagAmount);
                const offsetX = (perpX / length) * offsetAmount;
                const offsetY = (perpY / length) * offsetAmount;

                ctx.lineTo(baseX + offsetX, baseY + offsetY);
            }

            ctx.lineTo(endX, endY);
            ctx.stroke();

            // Dessiner un deuxi√®me √©clair plus fin et plus brillant
            ctx.strokeStyle = `rgba(150, 200, 255, ${0.9})`;
            ctx.lineWidth = 1;
            ctx.shadowBlur = 10;
            ctx.stroke();

            ctx.restore();
        }

        // Dessiner les √©clairs rouges de r√©g√©n√©ration
        function drawHealingLightning() {
            if (!isHealing || healingTargets.length === 0) return;

            // Calculer la position de d√©part (joueur)
            const startX = (player.x - camera.x) * BLOCK_SIZE + (player.width * BLOCK_SIZE) / 2;
            const startY = canvas.height - ((player.y - camera.y + player.normalHeight / 2) * BLOCK_SIZE);

            // Dessiner un √©clair vers chaque alli√©
            for (const target of healingTargets) {
                const endX = (target.x - camera.x) * BLOCK_SIZE + BLOCK_SIZE / 2;
                const endY = canvas.height - ((target.y - camera.y + 1) * BLOCK_SIZE);

                // Dessiner l'√©clair rouge avec effet d'ondulation
                ctx.save();
                ctx.strokeStyle = `rgba(255, 50, 50, ${0.7 + Math.sin(Date.now() / 50) * 0.3})`;
                ctx.lineWidth = 3;
                ctx.shadowColor = '#FF0000';
                ctx.shadowBlur = 15;

                ctx.beginPath();
                ctx.moveTo(startX, startY);

                // Cr√©er un √©clair avec segments en zigzag
                const segments = 6;
                const zigzagAmount = 20;

                for (let i = 1; i < segments; i++) {
                    const t = i / segments;
                    const baseX = startX + (endX - startX) * t;
                    const baseY = startY + (endY - startY) * t;

                    // Ajouter une ondulation perpendiculaire
                    const dx = endX - startX;
                    const dy = endY - startY;
                    const perpX = -dy;
                    const perpY = dx;
                    const length = Math.sqrt(perpX * perpX + perpY * perpY);
                    const offsetAmount = (Math.sin(Date.now() / 30 + i) * zigzagAmount);
                    const offsetX = (perpX / length) * offsetAmount;
                    const offsetY = (perpY / length) * offsetAmount;

                    ctx.lineTo(baseX + offsetX, baseY + offsetY);
                }

                ctx.lineTo(endX, endY);
                ctx.stroke();

                // Dessiner un deuxi√®me √©clair plus fin et plus brillant
                ctx.strokeStyle = `rgba(255, 150, 150, ${0.9})`;
                ctx.lineWidth = 1;
                ctx.shadowBlur = 10;
                ctx.stroke();

                ctx.restore();
            }
        }

        // Dessiner une barre de sant√© et de loyaut√© pour une cr√©ature
        function drawCreatureBars(centerX, y, health, maxHealth, loyalty, maxLoyalty, alignment, convertedByPlayer) {
            const barWidth = 50;
            const barHeight = 5;
            const barSpacing = 2;  // Espacement entre les deux barres
            const x = centerX - barWidth / 2;

            // Barre de sant√© (rouge) en haut
            if (health !== undefined && maxHealth !== undefined) {
                // Fond noir
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(x - 2, y - 2, barWidth + 4, barHeight + 4);

                // Barre grise (vide)
                ctx.fillStyle = '#333';
                ctx.fillRect(x, y, barWidth, barHeight);

                // Barre de sant√© (rouge)
                const healthPercent = health / maxHealth;
                const healthWidth = barWidth * healthPercent;
                ctx.fillStyle = '#FF0000';  // Rouge
                ctx.fillRect(x, y, healthWidth, barHeight);

                // Bordure blanche
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, barWidth, barHeight);
            }

            // Barre de loyaut√© en bas
            if (loyalty !== undefined && maxLoyalty !== undefined) {
                const loyaltyY = y + barHeight + barSpacing;

                // Fond noir
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(x - 2, loyaltyY - 2, barWidth + 4, barHeight + 4);

                // Barre de loyaut√© (couleur selon l'alignment)
                const loyaltyPercent = loyalty / maxLoyalty;
                const loyaltyWidth = barWidth * loyaltyPercent;

                // Couleur selon l'alignment et si converti par le joueur
                let barColor;
                let backgroundColor;
                if (convertedByPlayer) {
                    barColor = '#FF6B00';  // Orange (converti par le joueur)
                    backgroundColor = '#333';  // Fond gris fonc√©
                } else if (alignment === 'shadow') {
                    barColor = '#000000';  // Noir (cr√©ature d'ombre)
                    backgroundColor = '#FF6B00';  // Fond orange pour contraste
                } else if (alignment === 'light') {
                    barColor = '#FFD700';  // Or (cr√©ature de lumi√®re naturelle)
                    backgroundColor = '#333';  // Fond gris fonc√©
                } else {
                    barColor = '#888888';  // Gris (neutre/inconnu)
                    backgroundColor = '#333';  // Fond gris fonc√©
                }

                // Dessiner le fond avec la couleur adapt√©e
                ctx.fillStyle = backgroundColor;
                ctx.fillRect(x, loyaltyY, barWidth, barHeight);

                // Dessiner la barre de loyaut√©
                ctx.fillStyle = barColor;
                ctx.fillRect(x, loyaltyY, loyaltyWidth, barHeight);

                // Bordure blanche
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, loyaltyY, barWidth, barHeight);
            }
        }

        // Dessiner une barre de loyaut√© (ancienne fonction, conserv√©e pour compatibilit√©)
        function drawLoyaltyBar(centerX, y, loyalty, maxLoyalty) {
            const barWidth = 50;
            const barHeight = 6;
            const x = centerX - barWidth / 2;

            // Fond noir
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(x - 2, y - 2, barWidth + 4, barHeight + 4);

            // Barre grise (vide)
            ctx.fillStyle = '#333';
            ctx.fillRect(x, y, barWidth, barHeight);

            // Barre de loyaut√© (rouge -> jaune -> vert selon le niveau)
            const loyaltyPercent = loyalty / maxLoyalty;
            const currentWidth = barWidth * loyaltyPercent;

            // Couleur selon le niveau
            let barColor;
            if (loyaltyPercent > 0.6) {
                barColor = '#4B0082';  // Violet (loyal √† l'ombre)
            } else if (loyaltyPercent > 0.3) {
                barColor = '#FF6B00';  // Orange (neutre)
            } else {
                barColor = '#FF6B00';  // Orange (en conversion)
            }

            ctx.fillStyle = barColor;
            ctx.fillRect(x, y, currentWidth, barHeight);

            // Bordure blanche
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, barWidth, barHeight);
        }

        // Dessiner les escaliers avec l'art stairway.webp
        function drawStairways() {
            if (!sprites.stairway || !sprites.stairway.complete) return;

            for (const stairway of stairwayLocations) {
                const sx = (stairway.x - camera.x) * BLOCK_SIZE;
                const sy = canvas.height - ((stairway.y - camera.y) * BLOCK_SIZE);

                // V√©rifier si l'escalier est visible
                const dx = stairway.x - player.x;
                const dy = stairway.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance <= VISION_RADIUS) {
                    // L'image fait 864x1152, on la scale pour qu'elle fasse 3 blocs de large
                    const scaledWidth = BLOCK_SIZE * 3;  // 3 blocs de large
                    const scaledHeight = (sprites.stairway.height / sprites.stairway.width) * scaledWidth;

                    // Centrer l'image sur la position de l'escalier, pos√© sur le sol
                    const drawX = sx - scaledWidth / 2 + BLOCK_SIZE / 2;
                    const drawY = sy - scaledHeight;  // Positionn√© en bas (sur le sol)

                    ctx.save();
                    ctx.globalAlpha = 0.9;  // L√©g√®rement transparent pour se fondre
                    ctx.drawImage(
                        sprites.stairway,
                        drawX,
                        drawY,
                        scaledWidth,
                        scaledHeight
                    );
                    ctx.restore();

                    // Dessiner la barre de loyaut√© pour l'escalier
                    if (stairway.loyalty !== undefined) {
                        drawLoyaltyBar(sx, drawY - 10, stairway.loyalty, stairway.maxLoyalty);
                    }
                }
            }
        }

        // Dessiner les entit√©s (gardiens, cr√©atures)
        function drawEntities() {
            for (const entity of entities) {
                const ex = (entity.x - camera.x) * BLOCK_SIZE;
                const ey = canvas.height - ((entity.y - camera.y + 2) * BLOCK_SIZE);

                // V√©rifier si l'entit√© est visible
                const dx = entity.x - player.x;
                const dy = entity.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance <= VISION_RADIUS) {
                    // Animer l'entit√©
                    if (entity.animFrame !== undefined) {
                        entity.animFrame += entity.animSpeed || 0.05;
                        if (entity.animFrame >= 16) entity.animFrame = 0;
                    }

                    // Dessiner le b√©lier avec sprite anim√©
                    if ((entity.type === 'black_ram' || entity.type === 'golden_ram') && sprites.blackRam && sprites.blackRam.complete) {
                        // Sprite sheet 4x4 (16 frames) - 1068x1100
                        const frameWidth = 1068 / 4;   // 267px
                        const frameHeight = 1100 / 4;  // 275px

                        const frame = Math.floor(entity.animFrame);
                        const col = Math.floor(frame / 4);
                        const row = frame % 4;

                        const sx = col * frameWidth;
                        const sy = row * frameHeight;

                        // Taille: 2 blocs de large, 1 bloc de haut
                        const displayWidth = BLOCK_SIZE * 2;
                        const displayHeight = BLOCK_SIZE * 1;

                        // Positionn√© sur 2 blocs (√† partir de la position de l'entit√©)
                        const drawX = ex - displayWidth / 2 + BLOCK_SIZE / 2;
                        const drawY = canvas.height - ((entity.y - camera.y + 1) * BLOCK_SIZE);

                        ctx.save();
                        ctx.drawImage(
                            sprites.blackRam,
                            sx, sy, frameWidth, frameHeight,
                            drawX, drawY,
                            displayWidth, displayHeight
                        );

                        // Si c'est un b√©lier converti, ajouter une teinte orange
                        if (entity.type === 'golden_ram' && entity.convertedByPlayer) {
                            ctx.globalCompositeOperation = 'multiply';
                            ctx.fillStyle = 'rgba(255, 107, 0, 0.4)';  // Orange
                            ctx.fillRect(drawX, drawY, displayWidth, displayHeight);
                            ctx.globalCompositeOperation = 'source-over';

                            // Ajouter une lueur orange
                            const gradient = ctx.createRadialGradient(
                                drawX + displayWidth / 2, drawY + displayHeight / 2, 0,
                                drawX + displayWidth / 2, drawY + displayHeight / 2, BLOCK_SIZE * 2
                            );
                            gradient.addColorStop(0, 'rgba(255, 107, 0, 0.3)');  // Orange
                            gradient.addColorStop(1, 'rgba(255, 107, 0, 0)');
                            ctx.fillStyle = gradient;
                            ctx.fillRect(drawX - BLOCK_SIZE, drawY - BLOCK_SIZE, displayWidth + BLOCK_SIZE * 2, displayHeight + BLOCK_SIZE * 2);
                        }
                        ctx.restore();

                        // Dessiner les barres de sant√© et de loyaut√© pour tous les b√©liers
                        if (entity.health !== undefined || entity.loyalty !== undefined) {
                            drawCreatureBars(
                                drawX + displayWidth / 2,
                                drawY - 20,
                                entity.health,
                                entity.maxHealth,
                                entity.loyalty,
                                entity.maxLoyalty,
                                entity.alignment,
                                entity.convertedByPlayer
                            );
                        }
                    } else if (entity.type === 'ratman') {
                        // Dessiner l'homme-rat avec sprites anim√©s
                        let currentSprite = null;
                        let spriteWidth = 1276;  // idle dimensions
                        let spriteHeight = 1100;

                        // Choisir le sprite selon l'√©tat
                        if (entity.isAttacking) {
                            if (entity.facing === 'left' && sprites.ratmanAttackLeft && sprites.ratmanAttackLeft.complete) {
                                currentSprite = sprites.ratmanAttackLeft;
                                spriteWidth = 1330;
                                spriteHeight = 1100;
                            } else if (entity.facing === 'right' && sprites.ratmanAttackRight && sprites.ratmanAttackRight.complete) {
                                currentSprite = sprites.ratmanAttackRight;
                                spriteWidth = 1350;
                                spriteHeight = 1100;
                            }
                        } else if (entity.isMoving) {
                            if (entity.facing === 'left' && sprites.ratmanWalkLeft && sprites.ratmanWalkLeft.complete) {
                                currentSprite = sprites.ratmanWalkLeft;
                                spriteWidth = 1332;
                                spriteHeight = 1100;
                            } else if (entity.facing === 'right' && sprites.ratmanWalkRight && sprites.ratmanWalkRight.complete) {
                                currentSprite = sprites.ratmanWalkRight;
                                spriteWidth = 1407;
                                spriteHeight = 1100;
                            }
                        } else {
                            if (sprites.ratmanIdle && sprites.ratmanIdle.complete) {
                                currentSprite = sprites.ratmanIdle;
                                spriteWidth = 1276;
                                spriteHeight = 1100;
                            }
                        }

                        if (currentSprite) {
                            // Sprite sheet 4x4 (16 frames)
                            const frameWidth = spriteWidth / 4;
                            const frameHeight = spriteHeight / 4;

                            const frame = Math.floor(entity.animFrame);
                            const col = Math.floor(frame / 4);
                            const row = frame % 4;

                            const sx = col * frameWidth;
                            const sy = row * frameHeight;

                            // Taille: 2 blocs de haut
                            const displayHeight = BLOCK_SIZE * 2;
                            const scale = displayHeight / frameHeight;
                            const displayWidth = frameWidth * scale;

                            const drawX = ex - displayWidth / 2 + BLOCK_SIZE / 2;
                            const drawY = canvas.height - ((entity.y - camera.y + 2) * BLOCK_SIZE) - displayHeight + BLOCK_SIZE * 2;

                            ctx.save();

                            // Effet de teinte selon l'alignement
                            if (entity.alignment === 'light' && entity.convertedByPlayer) {
                                // Teinte orange pour les alli√©s convertis
                                ctx.globalCompositeOperation = 'source-over';
                                ctx.drawImage(
                                    currentSprite,
                                    sx, sy, frameWidth, frameHeight,
                                    drawX, drawY,
                                    displayWidth, displayHeight
                                );
                                ctx.globalCompositeOperation = 'multiply';
                                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                                ctx.fillRect(drawX, drawY, displayWidth, displayHeight);
                                ctx.globalCompositeOperation = 'source-over';
                            } else {
                                // Normal pour les monstres de l'ombre
                                ctx.drawImage(
                                    currentSprite,
                                    sx, sy, frameWidth, frameHeight,
                                    drawX, drawY,
                                    displayWidth, displayHeight
                                );
                            }

                            // Effet visuel de conversion
                            if (entity.conversionEffect) {
                                const alpha = entity.conversionEffect.timer / 60;
                                const color = entity.conversionEffect.type === 'convertToLight'
                                    ? `rgba(255, 215, 0, ${alpha * 0.5})`
                                    : `rgba(75, 0, 130, ${alpha * 0.5})`;

                                ctx.strokeStyle = color;
                                ctx.lineWidth = 3;
                                ctx.strokeRect(drawX, drawY, displayWidth, displayHeight);

                                // Particules
                                for (let p = 0; p < 3; p++) {
                                    const angle = (entity.conversionEffect.timer + p * 120) * 0.05;
                                    const radius = 30;
                                    const px = drawX + displayWidth / 2 + Math.cos(angle) * radius;
                                    const py = drawY + displayHeight / 2 + Math.sin(angle) * radius;

                                    ctx.fillStyle = color;
                                    ctx.beginPath();
                                    ctx.arc(px, py, 3, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }

                            ctx.restore();

                            // Dessiner les barres de sant√© et de loyaut√© pour les ratmen
                            if (entity.health !== undefined || entity.loyalty !== undefined) {
                                drawCreatureBars(
                                    drawX + displayWidth / 2,
                                    drawY - 20,
                                    entity.health,
                                    entity.maxHealth,
                                    entity.loyalty,
                                    entity.maxLoyalty,
                                    entity.alignment,
                                    entity.convertedByPlayer
                                );
                            }
                        } else {
                            // Fallback
                            ctx.fillStyle = entity.color;
                            ctx.beginPath();
                            ctx.arc(ex + BLOCK_SIZE / 2, ey + BLOCK_SIZE, BLOCK_SIZE, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    } else {
                        // Fallback: dessiner un placeholder color√©
                        ctx.fillStyle = entity.color;
                        ctx.beginPath();
                        ctx.arc(ex + BLOCK_SIZE / 2, ey + BLOCK_SIZE, BLOCK_SIZE / 2, 0, Math.PI * 2);
                        ctx.fill();

                        // Indicateur du type
                        ctx.fillStyle = 'white';
                        ctx.font = '12px monospace';
                        ctx.textAlign = 'center';
                        const label = entity.type === 'light_guardian' ? 'üëº' : 'üêè';
                        ctx.fillText(label, ex + BLOCK_SIZE / 2, ey + BLOCK_SIZE + 4);
                    }
                }
            }
        }

        // Dessiner le joueur avec sprites (grille 4√ó4)
        function drawPlayer() {
            const px = (player.x - camera.x) * BLOCK_SIZE;
            // Position Y: utiliser normalHeight pour le sprite m√™me si accroupi
            const py = canvas.height - ((player.y - camera.y + player.normalHeight) * BLOCK_SIZE);
            const width = player.width * BLOCK_SIZE;

            // Garder la taille normale du sprite m√™me en crouch
            // La hitbox est r√©duite mais pas le sprite visuel
            const displayHeight = player.normalHeight * BLOCK_SIZE;
            const height = displayHeight;

            let currentSprite = null;
            let currentSpriteWidth = 0;
            let currentSpriteHeight = 0;
            let frameWidth = 0;
            let frameHeight = 0;

            // Choisir le sprite selon l'√©tat (grille 4√ó4 = 16 frames)
            // Priorit√© 1: En l'air (saut)
            if (!player.onGround && sprites.heroJump && sprites.heroJump.complete) {
                currentSprite = sprites.heroJump;
                currentSpriteWidth = 856;
                currentSpriteHeight = 1308;
            } else if (player.isCrouching) {
                // Mode accroupi
                if (player.isMoving) {
                    // Accroupi et en mouvement: crawl
                    if (player.facing === 'left' && sprites.heroCrawlLeft && sprites.heroCrawlLeft.complete) {
                        currentSprite = sprites.heroCrawlLeft;
                        currentSpriteWidth = 1296;
                        currentSpriteHeight = 916;
                    } else if (player.facing === 'right' && sprites.heroCrawlRight && sprites.heroCrawlRight.complete) {
                        currentSprite = sprites.heroCrawlRight;
                        currentSpriteWidth = 1312;
                        currentSpriteHeight = 1096;
                    }
                } else {
                    // Accroupi et immobile: crouch-idle
                    if (sprites.heroCrouchIdle && sprites.heroCrouchIdle.complete) {
                        currentSprite = sprites.heroCrouchIdle;
                        currentSpriteWidth = 1000;
                        currentSpriteHeight = 1068;
                    }
                }
            } else if (player.isMoving) {
                // Mode marche debout
                if (player.facing === 'left' && sprites.heroWalkLeft && sprites.heroWalkLeft.complete) {
                    currentSprite = sprites.heroWalkLeft;
                    currentSpriteWidth = 684;
                    currentSpriteHeight = 1124;
                } else if (player.facing === 'right' && sprites.heroWalkRight && sprites.heroWalkRight.complete) {
                    currentSprite = sprites.heroWalkRight;
                    currentSpriteWidth = 1000;
                    currentSpriteHeight = 1760;
                }
            } else {
                // Mode idle debout
                if (sprites.heroIdle && sprites.heroIdle.complete) {
                    currentSprite = sprites.heroIdle;
                    currentSpriteWidth = 792;
                    currentSpriteHeight = 1768;
                }
            }

            // Dessiner le sprite ou fallback
            if (currentSprite) {
                // Grille 4√ó4 - se lit en colonnes (de haut en bas, puis colonne suivante)
                frameWidth = currentSpriteWidth / 4;
                frameHeight = currentSpriteHeight / 4;

                const frame = Math.floor(player.animFrame);
                // Lire colonne par colonne (de haut en bas)
                const col = Math.floor(frame / 4);
                const row = frame % 4;

                const sx = col * frameWidth;
                const sy = row * frameHeight;

                // Calculer la taille proportionnelle
                let scale, scaledWidth, finalHeight;

                if (player.isCrouching) {
                    // Pour les sprites accroupis: utiliser une hauteur plus petite
                    finalHeight = height * 0.6; // 60% de la hauteur normale
                    scale = finalHeight / frameHeight;
                    scaledWidth = frameWidth * scale;
                } else {
                    // Pour les sprites debout: hauteur normale
                    finalHeight = height;
                    scale = height / frameHeight;
                    scaledWidth = frameWidth * scale;
                }

                ctx.save();
                ctx.drawImage(
                    currentSprite,
                    sx, sy, frameWidth, frameHeight,
                    px + (width - scaledWidth) / 2, py + (height - finalHeight), scaledWidth, finalHeight
                );
                ctx.restore();
            } else {
                // Fallback: dessiner un rectangle simple
                // Garder la taille visuelle normale m√™me en crouch
                ctx.fillStyle = player.isCrouching ? '#4DB8E8' : '#2980b9';
                ctx.fillRect(px, py, width, height);
                ctx.strokeStyle = player.isCrouching ? '#ffeb3b' : '#00ff00';
                ctx.lineWidth = 3;
                ctx.strokeRect(px, py, width, height);

                // Ajouter une ligne pour montrer la hitbox r√©elle en crouch
                if (player.isCrouching) {
                    // Montrer o√π est la vraie hitbox (moiti√© basse)
                    const hitboxHeight = player.crouchHeight * BLOCK_SIZE;
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(px, py + (height - hitboxHeight), width, hitboxHeight);
                }
            }
        }

        // UI
        function updateUI() {
            document.getElementById('minedCount').textContent = minedCount;
            document.getElementById('position').textContent =
                `${Math.floor(player.x)}, ${Math.floor(player.y)}`;

            // Calculer la profondeur depuis la surface (niveau 255)
            const depthFromSurface = GRID_HEIGHT - Math.floor(player.y);
            document.getElementById('depth').textContent = depthFromSurface;

            document.getElementById('playerState').textContent = player.isCrouching ? 'Accroupi üü°' : 'Debout üü¢';

            // Afficher le mana
            document.getElementById('mana').textContent = Math.floor(player.mana);

            // Afficher la sant√©
            if (document.getElementById('health')) {
                document.getElementById('health').textContent = Math.floor(player.health);
            }

            // Afficher l'indicateur de repos
            if (document.getElementById('restIndicator')) {
                const isResting = !player.isMoving && player.attackCooldown === 0 && !isInvoking && !isHealing && player.onGround;
                if (isResting && player.restTimer >= 120) {
                    document.getElementById('restIndicator').textContent = 'üò¥ (r√©g√©n√©ration)';
                } else if (isResting && player.restTimer > 0) {
                    const secondsLeft = Math.ceil((120 - player.restTimer) / 60);
                    document.getElementById('restIndicator').textContent = `‚è≥ (${secondsLeft}s)`;
                } else {
                    document.getElementById('restIndicator').textContent = '';
                }
            }

            // Afficher les alli√©s
            document.getElementById('allies').textContent = player.currentAllies;
            document.getElementById('maxAllies').textContent = player.maxAllies;
        }

        // Lancer un sort de conversion (co√ªte 100% du mana)
        function castConversionSpell(spellType) {
            const spell = player.spells[spellType];

            // V√©rifier que le joueur a 100% de mana
            if (player.mana < player.maxMana) {
                console.log(`‚ùå ${spell.name}: Mana insuffisant (${Math.floor(player.mana)}/${player.maxMana}) - N√©cessite 100%`);
                return;
            }

            // Chercher une cible √† port√©e (monstre OU b√©lier noir)
            let targetEntity = null;
            let minDistance = spell.range;

            for (const entity of entities) {
                if (entity.type === 'ratman' || entity.type === 'black_ram') {
                    const dx = entity.x - player.x;
                    const dy = entity.y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance <= spell.range && distance < minDistance) {
                        targetEntity = entity;
                        minDistance = distance;
                    }
                }
            }

            if (!targetEntity) {
                console.log(`‚ùå ${spell.name}: Aucune cible √† port√©e`);
                return;
            }

            // Appliquer la conversion - co√ªte 100% du mana
            player.mana = 0;

            if (spellType === 'convertToLight') {
                // Conversion par le joueur
                if (targetEntity.type === 'black_ram') {
                    // Convertir le b√©lier noir
                    targetEntity.alignment = 'light';
                    targetEntity.color = '#FF6B00';  // Orange (converti par le joueur)
                    targetEntity.type = 'golden_ram';  // Changer le type
                    targetEntity.convertedByPlayer = true;  // Marquer comme converti
                    targetEntity.loyalty = 0.01;  // Repartir de presque 0 pour la remont√©e

                    // Augmenter la limite d'alli√©s du joueur
                    player.maxAllies++;

                    // Convertir tous les marqueurs de cette cave en marqueurs de Lumi√®re
                    convertCaveTerritory(targetEntity.x, targetEntity.y, TERRITORY_TYPES.SHADOW, TERRITORY_TYPES.LIGHT);

                    console.log(`üêè‚ú® B√©lier converti! +1 alli√© max (${player.currentAllies}/${player.maxAllies})`);
                } else if (targetEntity.type === 'ratman') {
                    // Convertir un monstre en alli√©
                    // V√©rifier si on a de la place pour un alli√©
                    if (player.currentAllies >= player.maxAllies) {
                        console.log(`‚ùå Limite d'alli√©s atteinte (${player.currentAllies}/${player.maxAllies}) - Convertissez d'abord un b√©lier!`);
                        player.mana = player.maxMana;  // Rendre le mana car √©chec
                        return;
                    }

                    targetEntity.alignment = 'light';
                    targetEntity.color = '#FF6B00';  // Orange (converti par le joueur)
                    targetEntity.convertedByPlayer = true;  // Marquer comme converti
                    targetEntity.loyalty = 0.01;  // Repartir de presque 0 pour la remont√©e
                    player.currentAllies++;

                    // Lib√©rer le slot du b√©lier pour qu'il puisse invoquer un nouveau monstre
                    // ET r√©duire sa loyaut√©
                    if (targetEntity.summonedBy) {
                        targetEntity.summonedBy.currentSummons--;

                        // R√©duire la loyaut√© du b√©lier qui a invoqu√© ce monstre
                        const summoner = targetEntity.summonedBy;
                        summoner.loyalty = Math.max(0, summoner.loyalty - 15);

                        // Si la loyaut√© tombe √† 0, conversion automatique
                        if (summoner.loyalty <= 0 && summoner.type === 'black_ram') {
                            summoner.type = 'golden_ram';
                            summoner.alignment = 'light';
                            summoner.color = '#FF6B00';  // Orange (converti par le joueur)
                            summoner.convertedByPlayer = true;  // Marquer comme converti
                            summoner.loyalty = 0.01;  // Repartir de presque 0 pour la remont√©e
                            player.maxAllies++;
                            convertCaveTerritory(summoner.x, summoner.y, TERRITORY_TYPES.SHADOW, TERRITORY_TYPES.LIGHT);
                            console.log(`‚ú® Le b√©lier a perdu toute loyaut√© et a √©t√© converti! +1 alli√© max`);
                        }
                    }
                    console.log(`‚ú® Monstre converti! (${player.currentAllies}/${player.maxAllies} alli√©s)`);
                }
            } else if (spellType === 'convertToShadow') {
                // Conversion √† l'Ombre
                if (targetEntity.type === 'ratman' && targetEntity.alignment === 'light') {
                    // D√©cr√©menter le compteur d'alli√©s
                    player.currentAllies--;
                }

                targetEntity.alignment = 'shadow';
                targetEntity.color = '#4B0082';  // Indigo
                console.log(`üåë Cible convertie √† l'Ombre! (${player.currentAllies}/${player.maxAllies} alli√©s)`);
            }

            // Effet visuel de conversion
            createConversionEffect(targetEntity, spellType);
        }

        // Convertir le territoire d'une cave (changer les marqueurs)
        function convertCaveTerritory(centerX, centerY, fromType, toType) {
            // Trouver tous les marqueurs proches du centre (m√™me cave)
            const maxDistance = 30;  // Distance max pour consid√©rer qu'on est dans la m√™me cave

            const newMarker = toType === TERRITORY_TYPES.LIGHT ? 'üåü' : 'üåë';
            const newStoneType = toType === TERRITORY_TYPES.LIGHT ? BLOCKS.STONE_LIGHT : BLOCKS.STONE_SHADOW;

            let convertedCount = 0;

            for (const marker of caveMarkers) {
                if (marker.type === fromType) {
                    const dx = marker.x - centerX;
                    const dy = marker.y - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance <= maxDistance) {
                        marker.symbol = newMarker;
                        marker.type = toType;

                        // Changer aussi le type de pierre
                        if (world[marker.y][marker.x] === BLOCKS.STONE_SHADOW || world[marker.y][marker.x] === BLOCKS.STONE_LIGHT) {
                            world[marker.y][marker.x] = newStoneType;
                        }

                        convertedCount++;
                    }
                }
            }

            console.log(`üîÑ ${convertedCount} marqueurs convertis en territoire de ${toType === TERRITORY_TYPES.LIGHT ? 'Lumi√®re' : 'Ombre'}`);
        }

        // Cr√©er un effet visuel de conversion
        function createConversionEffect(entity, spellType) {
            entity.conversionEffect = {
                timer: 60,  // Dur√©e de l'effet: 1 seconde
                type: spellType
            };
        }

        // Mettre √† jour les entit√©s (invocations, IA, etc.)
        function updateEntities() {
            // Processus d'invocation continue
            processContinuousInvoke();

            // Processus de r√©g√©n√©ration continue
            processHeal();

            // Gestion du cooldown d'attaque du joueur
            if (player.attackCooldown > 0) {
                player.attackCooldown--;
                if (player.attackCooldown === 0) {
                    player.isAttacking = false;
                }
            }

            // V√©rifier si le joueur est mort
            if (player.health <= 0) {
                console.log('üíÄ Vous √™tes mort! Rechargez la page pour recommencer.');
                // Arr√™ter le jeu
                cancelAnimationFrame(gameLoopId);
                // Afficher un message
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'red';
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
                ctx.fillStyle = 'white';
                ctx.font = '24px Arial';
                ctx.fillText('Rechargez la page (F5) pour recommencer', canvas.width / 2, canvas.height / 2 + 50);
                return;
            }

            // Faire remonter la loyaut√© des cr√©atures converties par le joueur
            for (const entity of entities) {
                if (entity.convertedByPlayer && entity.loyalty < entity.maxLoyalty) {
                    // Remonter progressivement: 10 par seconde = 10/60 par frame
                    const loyaltyGainPerFrame = 10 / 60;
                    entity.loyalty = Math.min(entity.maxLoyalty, entity.loyalty + loyaltyGainPerFrame);
                }
            }

            // R√©g√©n√©ration du mana du joueur (seulement si pas en train d'invoquer ou de soigner)
            if (player.mana < player.maxMana && !isInvoking && !isHealing) {
                player.mana = Math.min(player.maxMana, player.mana + player.manaRegen);
            }

            // Syst√®me de repos pour r√©g√©n√©ration de vie
            const isResting = !player.isMoving && player.attackCooldown === 0 && !isInvoking && !isHealing && player.onGround;

            if (isResting) {
                // Incr√©menter le timer de repos
                player.restTimer++;

                // Apr√®s 2 secondes (120 frames) de repos, commencer la r√©g√©n√©ration
                if (player.restTimer >= 120 && player.health < player.maxHealth) {
                    player.health = Math.min(player.maxHealth, player.health + player.healthRegen);
                }
            } else {
                // R√©initialiser le timer si le joueur bouge/attaque
                player.restTimer = 0;
            }

            // Mettre √† jour les cooldowns des escaliers
            for (const stairway of stairwayLocations) {
                if (stairway.invokeCooldown > 0) {
                    stairway.invokeCooldown--;
                }
            }

            for (let i = 0; i < entities.length; i++) {
                const entity = entities[i];

                // Mettre √† jour le cooldown d'invocation des b√©liers
                if (entity.invokeCooldown > 0) {
                    entity.invokeCooldown--;
                }

                // Effet de conversion
                if (entity.conversionEffect) {
                    entity.conversionEffect.timer--;
                    if (entity.conversionEffect.timer <= 0) {
                        delete entity.conversionEffect;
                    }
                }

                // Comportement du b√©lier noir: invoquer des monstres (mais pas les b√©liers dor√©s)
                if (entity.type === 'black_ram') {
                    entity.summonTimer++;

                    // V√©rifier la distance avec le joueur
                    const dx = entity.x - player.x;
                    const dy = entity.y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // Si le joueur est proche (dans un rayon de 10 blocs) et il est temps d'invoquer
                    if (distance <= 10 && entity.summonTimer >= entity.summonInterval && entity.currentSummons < entity.maxSummons) {
                        summonMonster(entity);
                        entity.summonTimer = 0;
                        entity.currentSummons++;

                        // R√©duire la loyaut√© du b√©lier quand il invoque
                        entity.loyalty = Math.max(0, entity.loyalty - 5);

                        // Si la loyaut√© tombe √† 0, conversion automatique
                        if (entity.loyalty <= 0) {
                            entity.type = 'golden_ram';
                            entity.alignment = 'light';
                            entity.color = '#FF6B00';  // Orange (converti par le joueur)
                            entity.convertedByPlayer = true;  // Marquer comme converti
                            entity.loyalty = 0.01;  // Repartir de presque 0 pour la remont√©e
                            player.maxAllies++;
                            convertCaveTerritory(entity.x, entity.y, TERRITORY_TYPES.SHADOW, TERRITORY_TYPES.LIGHT);
                            console.log(`‚ú® Le b√©lier s'est √©puis√© et a √©t√© converti! +1 alli√© max`);
                        }
                    }
                } else if (entity.type === 'golden_ram' && entity.convertedByPlayer) {
                    // B√©lier converti: invoque des ratmen alli√©s comme le font les rams noirs
                    entity.summonTimer++;

                    // V√©rifier la distance avec le joueur OU un ennemi proche
                    const dx = entity.x - player.x;
                    const dy = entity.y - player.y;
                    const distanceToPlayer = Math.sqrt(dx * dx + dy * dy);

                    // Chercher des ennemis proches
                    let hasEnemyNearby = false;
                    for (const other of entities) {
                        if ((other.type === 'black_ram' || (other.type === 'ratman' && other.alignment === 'shadow')) && other !== entity) {
                            const dx = other.x - entity.x;
                            const dy = other.y - entity.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist <= 10) {
                                hasEnemyNearby = true;
                                break;
                            }
                        }
                    }

                    // Si joueur proche OU ennemi proche, et c'est le moment d'invoquer
                    if ((distanceToPlayer <= 10 || hasEnemyNearby) && entity.summonTimer >= entity.summonInterval && entity.currentSummons < entity.maxSummons) {
                        summonMonster(entity);
                        entity.summonTimer = 0;
                    }
                }

                // Comportement des hommes-rats invoqu√©s
                if (entity.type === 'ratman') {
                    // Initialiser l'alignement si non d√©fini
                    if (!entity.alignment) {
                        entity.alignment = 'shadow';  // Par d√©faut: ombre
                    }

                    // D√©terminer la cible selon l'alignement
                    let target = null;
                    if (entity.alignment === 'shadow') {
                        // Les monstres de l'ombre attaquent le joueur
                        target = player;
                    } else if (entity.alignment === 'light' && entity.convertedByPlayer) {
                        // Les monstres convertis par le joueur: d√©fendent le joueur
                        // 1. Chercher un ennemi proche du joueur
                        let closestEnemy = null;
                        let minDist = Infinity;
                        const defenseRange = 5;  // Port√©e de d√©fense

                        for (const other of entities) {
                            // Cibler les cr√©atures shadow hostiles (seulement les ratmen, pas les b√©liers)
                            if ((other.type === 'ratman' && other.alignment === 'shadow') && other !== entity) {
                                const dxToPlayer = other.x - player.x;
                                const dyToPlayer = other.y - player.y;
                                const distToPlayer = Math.sqrt(dxToPlayer * dxToPlayer + dyToPlayer * dyToPlayer);

                                // Si l'ennemi est proche du joueur
                                if (distToPlayer < defenseRange) {
                                    const dx = other.x - entity.x;
                                    const dy = other.y - entity.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    if (dist < minDist) {
                                        minDist = dist;
                                        closestEnemy = other;
                                    }
                                }
                            }
                        }

                        // Si un ennemi est proche, l'attaquer, sinon suivre le joueur
                        target = closestEnemy || player;
                    } else if (entity.alignment === 'light') {
                        // Les monstres de la lumi√®re naturels attaquent les b√©liers noirs
                        let closestRam = null;
                        let minDist = Infinity;
                        for (const other of entities) {
                            if (other.type === 'black_ram') {
                                const dx = other.x - entity.x;
                                const dy = other.y - entity.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist < minDist) {
                                    minDist = dist;
                                    closestRam = other;
                                }
                            }
                        }
                        target = closestRam || player;  // Fallback sur le joueur
                    }

                    if (target) {
                        // IA: se d√©placer vers la cible
                        const dx = target.x - entity.x;
                        const dy = target.y - entity.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        // D√©terminer la direction
                        if (dx > 0) {
                            entity.facing = 'right';
                        } else if (dx < 0) {
                            entity.facing = 'left';
                        }

                        // Comportement selon la cible
                        const isFollowingPlayer = (target === player && entity.convertedByPlayer);
                        const followDistance = isFollowingPlayer ? 2.0 : 0.5;  // Distance de garde pour les alli√©s
                        const attackDistance = 1.5;

                        // Si proche de l'ennemi: attaquer
                        if (!isFollowingPlayer && distance < attackDistance && entity.attackCooldown <= 0) {
                            entity.isAttacking = true;
                            entity.isMoving = false;
                            entity.attackCooldown = 120;  // 2 secondes de cooldown
                            entity.animFrame = 0;  // Red√©marrer l'animation d'attaque

                            // Infliger des d√©g√¢ts √† la cible
                            const damage = 5;  // D√©g√¢ts par attaque (r√©duit pour meilleur √©quilibre)
                            if (target === player) {
                                // Attaquer le joueur
                                if (player.health !== undefined) {
                                    player.health = Math.max(0, player.health - damage);
                                    console.log(`üí• Le ratman vous attaque! ${player.health}/${player.maxHealth} HP`);
                                }
                            } else if (target.health !== undefined) {
                                // Attaquer une cr√©ature
                                target.health = Math.max(0, target.health - damage);
                                console.log(`üí• Attaque! Cible: ${target.health}/${target.maxHealth} HP`);
                            }
                        } else if (distance > followDistance) {
                            // Si trop loin: poursuivre
                            entity.isAttacking = false;
                            entity.isMoving = true;
                            const speed = 0.03;
                            entity.vx = (dx / distance) * speed;
                            entity.vy = (dy / distance) * speed;
                            entity.x += entity.vx;
                            entity.y += entity.vy;
                        } else {
                            // √Ä bonne distance: rester en position
                            entity.isMoving = false;
                        }
                    }

                    // Cooldown d'attaque
                    if (entity.attackCooldown > 0) {
                        entity.attackCooldown--;
                        if (entity.attackCooldown === 0) {
                            entity.isAttacking = false;
                        }
                    }

                    // Animation
                    entity.animFrame += entity.animSpeed;
                    if (entity.animFrame >= 16) entity.animFrame = 0;

                    // V√©rifier la sant√© de l'entit√©
                    if (entity.health !== undefined && entity.health <= 0) {
                        // L'entit√© est morte
                        entities.splice(i, 1);
                        i--;
                        if (entity.summonedBy) {
                            entity.summonedBy.currentSummons--;
                        }
                        // Si c'est un ram converti, r√©duire maxAllies
                        if (entity.type === 'golden_ram' && entity.convertedByPlayer) {
                            player.maxAllies = Math.max(1, player.maxAllies - 1);
                            console.log(`‚ò†Ô∏è Un b√©lier converti est mort. -1 alli√© max (${player.maxAllies})`);
                        }
                        // Si c'est un ratman alli√©, r√©duire currentAllies
                        if (entity.type === 'ratman' && entity.convertedByPlayer) {
                            player.currentAllies = Math.max(0, player.currentAllies - 1);
                            console.log(`‚ò†Ô∏è Un ratman alli√© est mort. (${player.currentAllies}/${player.maxAllies} alli√©s)`);
                        }
                        continue;  // Passer √† l'entit√© suivante
                    }

                    // Dur√©e de vie (sauf si converti √† la Lumi√®re)
                    if (entity.alignment !== 'light') {
                        entity.lifetime--;
                        if (entity.lifetime <= 0) {
                            // Marquer pour suppression
                            entities.splice(i, 1);
                            i--;
                            if (entity.summonedBy) {
                                entity.summonedBy.currentSummons--;
                            }
                        }
                    }
                }
            }
        }

        // √âtat de l'invocation continue
        let isInvoking = false;
        let currentInvokeTarget = null;

        // √âtat du sort de r√©g√©n√©ration
        let isHealing = false;
        let healingTargets = [];  // Liste des alli√©s √† r√©g√©n√©rer

        // Trouver la cr√©ature la plus proche pour l'invocation
        function findClosestInvokableTarget() {
            const invokeRange = 3;  // Port√©e d'invocation: 3 blocs
            let target = null;
            let minDistance = invokeRange;
            let targetType = null;

            // V√©rifier les b√©liers (seulement ceux non convertis)
            for (const entity of entities) {
                if ((entity.type === 'black_ram' || entity.type === 'golden_ram') && !entity.convertedByPlayer) {
                    const dx = entity.x - player.x;
                    const dy = entity.y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance <= invokeRange && distance < minDistance) {
                        target = entity;
                        minDistance = distance;
                        targetType = 'ram';
                    }
                }
            }

            // V√©rifier les monstres ratman (seulement ceux non convertis)
            for (const entity of entities) {
                if (entity.type === 'ratman' && !entity.convertedByPlayer) {
                    const dx = entity.x - player.x;
                    const dy = entity.y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance <= invokeRange && distance < minDistance) {
                        target = entity;
                        minDistance = distance;
                        targetType = 'ratman';
                    }
                }
            }

            // V√©rifier les escaliers (seulement ceux non convertis)
            for (const stairway of stairwayLocations) {
                if (stairway.converted) continue;  // Ignorer les escaliers d√©j√† convertis

                const dx = stairway.x - player.x;
                const dy = stairway.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance <= invokeRange && distance < minDistance) {
                    target = stairway;
                    minDistance = distance;
                    targetType = 'stairway';
                }
            }

            return { target, targetType };
        }

        // Processus d'invocation continue (appel√© chaque frame)
        function processContinuousInvoke() {
            if (!isInvoking) return;

            // Drain de mana: 5 par seconde = 5/60 par frame (√† 60 fps)
            const manaDrainPerFrame = 5 / 60;

            // V√©rifier si le joueur a encore du mana
            if (player.mana <= 0) {
                isInvoking = false;
                currentInvokeTarget = null;
                return;
            }

            // Trouver la cible la plus proche
            const { target, targetType } = findClosestInvokableTarget();

            if (!target) {
                // Pas de cible √† port√©e, arr√™ter l'invocation
                currentInvokeTarget = null;
                return;
            }

            // Mettre √† jour la cible actuelle
            currentInvokeTarget = target;

            // Consommer le mana du joueur
            player.mana = Math.max(0, player.mana - manaDrainPerFrame);

            // R√©duire la loyaut√© de la cible: m√™me taux que le mana (5/60 par frame)
            const loyaltyDrainPerFrame = 5 / 60;

            if (target.loyalty !== undefined) {
                target.loyalty = Math.max(0, target.loyalty - loyaltyDrainPerFrame);

                // V√©rifier si la loyaut√© est tomb√©e √† 0 pour conversion
                if (target.loyalty <= 0) {
                    if (targetType === 'ram' && target.type === 'black_ram') {
                        // Conversion du b√©lier noir
                        target.type = 'golden_ram';
                        target.alignment = 'light';
                        target.color = '#FF6B00';  // Orange (converti par le joueur)
                        target.convertedByPlayer = true;  // Marquer comme converti
                        target.loyalty = 0.01;  // Repartir de presque 0 pour la remont√©e
                        player.maxAllies++;
                        convertCaveTerritory(target.x, target.y, TERRITORY_TYPES.SHADOW, TERRITORY_TYPES.LIGHT);
                        console.log(`‚ú® Le b√©lier noir a √©t√© converti par invocation! +1 alli√© max`);
                        isInvoking = false;
                        currentInvokeTarget = null;
                    } else if (targetType === 'ratman' && target.alignment === 'shadow') {
                        // Conversion du ratman
                        if (player.currentAllies < player.maxAllies) {
                            target.alignment = 'light';
                            target.color = '#FF6B00';  // Orange (converti par le joueur)
                            target.convertedByPlayer = true;  // Marquer comme converti
                            target.loyalty = 0.01;  // Repartir de presque 0 pour la remont√©e
                            player.currentAllies++;

                            // Lib√©rer le slot du b√©lier et r√©duire sa loyaut√©
                            if (target.summonedBy) {
                                target.summonedBy.currentSummons--;

                                const summoner = target.summonedBy;
                                summoner.loyalty = Math.max(0, summoner.loyalty - 15);

                                // Si la loyaut√© du b√©lier tombe √† 0
                                if (summoner.loyalty <= 0 && summoner.type === 'black_ram') {
                                    summoner.type = 'golden_ram';
                                    summoner.alignment = 'light';
                                    summoner.color = '#FF6B00';  // Orange (converti par le joueur)
                                    summoner.convertedByPlayer = true;  // Marquer comme converti
                                    summoner.loyalty = 0.01;  // Repartir de presque 0 pour la remont√©e
                                    player.maxAllies++;
                                    convertCaveTerritory(summoner.x, summoner.y, TERRITORY_TYPES.SHADOW, TERRITORY_TYPES.LIGHT);
                                    console.log(`‚ú® Le b√©lier a perdu toute loyaut√© et a √©t√© converti! +1 alli√© max`);
                                }
                            }

                            console.log(`‚ú® Monstre converti √† la Lumi√®re! (${player.currentAllies}/${player.maxAllies} alli√©s)`);
                        }
                        isInvoking = false;
                        currentInvokeTarget = null;
                    } else if (targetType === 'stairway') {
                        // B√©n√©diction de l'escalier
                        console.log(`‚ú® L'escalier vous a accord√© sa b√©n√©diction! +1 alli√© max`);
                        player.mana = player.maxMana;
                        player.maxAllies++;
                        target.converted = true;  // Marquer comme converti
                        isInvoking = false;
                        currentInvokeTarget = null;
                    }
                }
            }
        }

        // Processus de r√©g√©n√©ration continue (appel√© chaque frame)
        function processHeal() {
            if (!isHealing) return;

            // Drain de mana: 10 par seconde = 10/60 par frame (plus co√ªteux que l'invocation)
            const manaDrainPerFrame = 10 / 60;

            // V√©rifier si le joueur a encore du mana
            if (player.mana <= 0) {
                isHealing = false;
                healingTargets = [];
                return;
            }

            // Trouver tous les alli√©s √† port√©e qui ont besoin de soins
            const healRange = 5;  // Port√©e de soin: 5 blocs
            const healPerFrame = 20 / 60;  // R√©g√©n√©ration: 20 HP par seconde

            healingTargets = [];
            for (const entity of entities) {
                // Cibler seulement les alli√©s convertis par le joueur qui sont bless√©s
                if (entity.convertedByPlayer && entity.health !== undefined && entity.health < entity.maxHealth) {
                    const dx = entity.x - player.x;
                    const dy = entity.y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance <= healRange) {
                        healingTargets.push(entity);
                        // R√©g√©n√©rer la sant√© de l'alli√©
                        entity.health = Math.min(entity.maxHealth, entity.health + healPerFrame);
                    }
                }
            }

            // Si aucun alli√© √† soigner, arr√™ter le sort
            if (healingTargets.length === 0) {
                isHealing = false;
                return;
            }

            // Consommer le mana du joueur (proportionnel au nombre d'alli√©s soign√©s)
            const totalManaDrain = manaDrainPerFrame * healingTargets.length;
            player.mana = Math.max(0, player.mana - totalManaDrain);
        }

        // Ancienne fonction invokeNearby (conserv√©e pour compatibilit√© mais non utilis√©e)
        function invokeNearby() {
            // Cette fonction n'est plus utilis√©e avec le syst√®me continu
        }

        // Invoquer un monstre
        function summonMonster(summoner) {
            // Cr√©er un homme-rat pr√®s du b√©lier
            const angle = Math.random() * Math.PI * 2;
            const distance = 2 + Math.random() * 2;  // Entre 2 et 4 blocs de distance

            // D√©terminer si c'est un alli√© ou un ennemi selon le summoner
            const isAlly = summoner.convertedByPlayer === true;

            // Pour les alli√©s, v√©rifier qu'on a de la place
            if (isAlly && player.currentAllies >= player.maxAllies) {
                console.log(`‚ùå Invocation annul√©e: limite d'alli√©s atteinte (${player.currentAllies}/${player.maxAllies})`);
                return;
            }

            const monster = {
                type: 'ratman',
                x: summoner.x + Math.cos(angle) * distance,
                y: summoner.y + Math.sin(angle) * distance,
                vx: 0,
                vy: 0,
                color: isAlly ? '#FF6B00' : '#8B008B',  // Orange si alli√©, violet fonc√© si ennemi
                animFrame: 0,
                animSpeed: 0.05,
                summonedBy: summoner,  // R√©f√©rence au b√©lier qui l'a invoqu√©
                lifetime: isAlly ? Infinity : 1800,  // Infini si alli√©, 30 secondes si ennemi
                facing: 'right',  // Direction
                isMoving: false,
                isAttacking: false,
                attackCooldown: 0,
                health: 50,        // Points de vie du rat
                maxHealth: 50,
                loyalty: 100,      // Loyaut√© du rat
                maxLoyalty: 100,
                alignment: isAlly ? 'light' : 'shadow',  // Alignement selon le summoner
                convertedByPlayer: isAlly  // Marquer si c'est un alli√© du joueur
            };

            // Si c'est un alli√©, incr√©menter le compteur d'alli√©s
            if (isAlly) {
                player.currentAllies++;
                console.log(`üêÄ‚ú® Ratman alli√© invoqu√©! (${player.currentAllies}/${player.maxAllies} alli√©s)`);
            } else {
                console.log(`üêÄ Homme-rat ennemi invoqu√© en (${Math.floor(monster.x)}, ${Math.floor(monster.y)})`);
            }

            summoner.currentSummons++;
            entities.push(monster);
        }

        // ID de la boucle de jeu pour pouvoir l'arr√™ter
        let gameLoopId = null;

        // Boucle de jeu
        function gameLoop() {
            updatePhysics();
            updateEntities();
            drawWorld();
            updateUI();
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        // Contr√¥les
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;

            if ((e.key.toLowerCase() === 'z' || e.key.toLowerCase() === 'w') && player.onGround) {
                player.vy = player.jumpPower;
                player.onGround = false;
            }

            if (e.key === 'Shift' || e.key.toLowerCase() === 's') {
                if (!player.isCrouching) {
                    player.isCrouching = true;
                    player.height = player.crouchHeight;
                }
            }

            if (e.key.toLowerCase() === 'e') {
                isInvoking = true;
            }

            if (e.key.toLowerCase() === 'a') {
                // Attaque avec la touche A
                if (player.attackCooldown <= 0) {
                    player.isAttacking = true;
                    player.attackCooldown = 60;  // 1 seconde de cooldown

                    // Trouver et attaquer les ennemis √† port√©e
                    for (const entity of entities) {
                        if ((entity.type === 'black_ram' || (entity.type === 'ratman' && entity.alignment === 'shadow')) && entity.health !== undefined) {
                            const dx = entity.x - player.x;
                            const dy = entity.y - player.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);

                            if (distance <= player.attackRange) {
                                entity.health = Math.max(0, entity.health - player.attackDamage);
                                console.log(`‚öîÔ∏è Vous attaquez! Cible: ${entity.health}/${entity.maxHealth} HP`);
                            }
                        }
                    }
                }
            }

            if (e.key.toLowerCase() === 'b') {
                // Toggle mode cam√©ra libre
                camera.freeView = !camera.freeView;
                if (camera.freeView) {
                    // Initialiser la position de la cam√©ra libre √† la position actuelle
                    camera.freeX = camera.x;
                    camera.freeY = camera.y;
                    document.getElementById('debugMode').style.display = 'block';
                    console.log('üì∑ Mode cam√©ra libre activ√© (ZQSD pour se d√©placer)');
                } else {
                    document.getElementById('debugMode').style.display = 'none';
                    console.log('üì∑ Mode cam√©ra normale (suit le joueur)');
                }
            }

            // Sort de conversion (touche C)
            if (e.key.toLowerCase() === 'c') {
                castConversionSpell('convertToLight');
            }

            // Sort de r√©g√©n√©ration (touche H)
            if (e.key.toLowerCase() === 'h') {
                isHealing = true;
            }

            if (e.key.toLowerCase() === 'r') {
                // Creuser une galerie (2 carr√©s devant le joueur)
                const direction = player.facing === 'right' ? 1 : -1;
                const digX = Math.floor(player.x + direction);
                const digY = Math.floor(player.y);

                // Creuser 2 blocs: √† la hauteur du joueur et au-dessus
                for (let dy = 0; dy <= 1; dy++) {
                    const targetY = digY + dy;
                    if (digX >= 0 && digX < GRID_WIDTH && targetY >= 0 && targetY < GRID_HEIGHT) {
                        const blockType = world[targetY][digX];
                        // Ne pas creuser le bedrock
                        if (blockType !== BLOCKS.AIR && blockType !== BLOCKS.BEDROCK) {
                            world[targetY][digX] = BLOCKS.AIR;
                            minedCount++;
                        }
                    }
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;

            if (e.key === 'Shift' || e.key.toLowerCase() === 's') {
                // Essayer de se relever uniquement si c'est possible
                if (!checkCollision(player.x, player.y, player.width, player.normalHeight)) {
                    player.height = player.normalHeight;
                    player.isCrouching = false;
                }
                // Sinon, rester accroupi (ne rien faire)
            }

            if (e.key.toLowerCase() === 'e') {
                isInvoking = false;
                currentInvokeTarget = null;
            }

            if (e.key.toLowerCase() === 'h') {
                isHealing = false;
                healingTargets = [];
            }
        });

        setInterval(() => {
            const currentSpeed = player.isCrouching ? player.crouchSpeed : player.speed;

            if (keys['q'] || keys['arrowleft']) {
                player.vx = -currentSpeed;
                player.facing = 'left';
            } else if (keys['d'] || keys['arrowright']) {
                player.vx = currentSpeed;
                player.facing = 'right';
            }
        }, 16);

        // Creuser
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const bx = Math.floor(mouseX / BLOCK_SIZE + camera.x);
            const by = Math.floor((canvas.height - mouseY) / BLOCK_SIZE + camera.y);

            if (bx >= 0 && bx < GRID_WIDTH && by >= 0 && by < GRID_HEIGHT) {
                const dx = bx - player.x;
                const dy = by - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance <= 5) {
                    if (world[by][bx] !== BLOCKS.AIR && world[by][bx] !== BLOCKS.BEDROCK) {
                        world[by][bx] = BLOCKS.AIR;
                        minedCount++;
                    } else if (world[by][bx] === BLOCKS.AIR) {
                        if (!checkCollision(player.x, player.y, player.width, player.height)) {
                            world[by][bx] = BLOCKS.DIRT;
                        }
                    }
                }
            }
        });

        // D√©marrer
        async function start() {
            console.log('üßô Oubliettes - Chargement...');

            await loadSprites();

            console.log('‚úÖ Sprites charg√©s');

            initWorld();

            document.getElementById('loading').style.display = 'none';
            document.getElementById('info').style.display = 'block';
            document.getElementById('controls').style.display = 'block';

            gameLoop();

            console.log('üßô Oubliettes d√©marr√© !');
        }

        start();
    </script>
</body>
</html>
